{
    "collab_server" : "",
    "contents" : "genData = function(nBetween, nWithin, fun1 = 'rnorm', fun2 = 'rnorm',\n                   args1 = list(mean = 1e2, sd = 1), args2 = list(sd = 5)) {\n  args11 = args1[names(args1) %in% names(formals(fun1))] # only retain function args actually used in fun1\n  args22 = args2[names(args2) %in% names(formals(fun2))] # only retain function args actually used in fun2\n  mu = do.call(fun1, c(list(n = nBetween), args11)) # do function fun1 with arguments\n  # make a list where every element in data.list with fun2 executed with arguments\n  data.list = lapply(1L:nBetween, function(i) {\n    do.call(fun2, c(list(n = nWithin, mu[i]), args22))\n  })\n\n  # return output, data contains 100 datasets, mu contains the true means\n  return(list(data = data.list, mu = mu))\n}\n\n# x = genData(...)$data\nJS.est = function(x) {\n  y = unlist(lapply(x, mean)) # calc mean by group\n  yh = mean(unlist(x)) # calc mean of all data together\n  sig = var(y) # calc variance of the group means\n  if (is.na(sig)) {\n    sig = 0\n  }\n  k = length(x) # number of means to estimate (== number, of groups)\n  c = 1 - (k-3)*sig / (sum((y - yh)^2)) # formula for shrinkage factor from paper\n  if (is.nan(c)) {\n    c = 1\n  }\n  z = yh + c * (y - yh) # formula for stein estimates from paper\n  return(list(z = z, c = c)) # return output\n}\n\nJS.mean = function(y, dataset = NULL, samples = NULL) {\n  sig = var(y)\n  if (is.na(sig)) sig = 0\n  k = length(y)\n  yh = mean(y)\n  c = 1 - (k-3)*sig / (sum((y - yh)^2)) # formula for shrinkage factor from paper\n  if (is.nan(c)) {\n    c = 1\n  }\n  z = yh + c * (y - yh)\n  return(z)\n  #return(list(z = z, c = c)) # return output\n}\n\nEB = function(z) {\n  (1 - (length(z) - 2) / sum(z^2))*z\n}\n\nRMSE = function(x, y) {\n  return(sqrt(mean((x - y)^2)))\n}\n\n# sample a % of observations and calculate the mean of it - deprecated?\npartialMean = function(x, sample) {\n  mean(sample(x, ceiling(length(x)*sample), replace = FALSE))\n}\n\npartialLength = function(x, sample) {\n  length(sample(x, ceiling(length(x)*sample), replace = FALSE))\n}\n\n\nshrinkagePlot = function(JS, Mu, trueMean, estName, usePlotly = FALSE, useGgplot = FALSE, ...) {\n  x = t(cbind(Mu, JS, trueMean)) # bind estimates in a matrix\n  x = as.matrix(x[, order(x[1, ])]) # order matrix by first column\n  estName = gsub(\" \", \"\\n\", estName)\n  if (!usePlotly && !useGgplot) {\n    y = t(matrix(2:0, ncol(x), 3, TRUE))\n    y = y + apply(x, 2, duplicated)*.1\n    matplot(x, y, ...) # plot matrix.\n  } else {\n    dat = data.frame(x = c(x),\n                     y = c(t(matrix(factor(c('Sample\\nMean', estName, 'True\\nMean')), ncol(x), 3, TRUE))),\n                     group = factor(rep(1:ncol(x), 1, NA, 3)))\n    if (useGgplot) {\n      library(ggplot2)\n      g = ggplot(data = dat, aes(x = x, y = y, group = group, color = group)) +\n        geom_line() +\n        geom_point() + scale_y_discrete('')\n      if (usePlotly) {\n        library(plotly)\n        g = ggplotly(g)\n      }\n    } else {\n      library(plotly)\n      levels(dat[, 2])[levels(dat[, 2])=='James\\nStein'] <- 'James<br>Stein'\n      g = plot_ly(data = dat, x = x, y = y, group = group, type = 'line',\n                  color = group) %>% layout(yaxis = list(title = '', autorange = \"reversed\"))\n    }\n    return(suppressWarnings(g))\n  }\n}\n\n# Eredivisie functions\ncalcPointsDate = function(dat, date) {\n  idx = dat$Date < date\n  return(calcPoints(dat[idx, ]))\n}\n\ncalcPoints = function(dat) {\n  clubs = unique(dat$Home)\n  out = matrix(0, 3, ncol = length(clubs))\n  colnames(out) = clubs\n  for (i in seq_along(clubs)) {\n    ih = dat$Home == clubs[i]\n    ia = dat$Away == clubs[i]\n    out[1, i] = sum(dat$homeScore[ih], dat$awayScore[ia])\n    out[2, i] = sum(ih, ia)\n  }\n  out[3, ] = out[1, ] / out[2, ]\n  return(out)\n}\n\neredivisieTable = function() {\n  df = read.csv(file = \"Descriptions/EredivisieTable.txt\", header = FALSE,\n                colClasses = c(\"character\", rep(\"integer\", 8)))\n  colnames(df) = c(\"Club\", \"Played\", \"Won\", \"Tied\", \"Lost\", \"Points\", \"Goals made\",\n                   \"Goals against\", \"Goal Difference\")\n  df$`Goal / Match Ratio` = round(df$`Goals made` / 34, 3)\n  return(df)\n}\n\n# Olympics functions\nolympicsTable = function() {\n  d12 = read.table(\"Datasets/Olympics2012.txt\", header = TRUE, sep = \" \")\n  d16 = read.table(\"Datasets/Olympics2016.txt\", header = TRUE, sep = \" \")\n  colnames(d16)[5] = \"Population per Medal\"\n  return(d16)\n}\n\n# hierarchicalBayes functions\ninvLogit = function(x) exp(x) / (1 + exp(x))\n\nmodelBinom = function() {\n  mu ~ dnorm(0, 1)\n  prec ~ dgamma(.0001, .0001)\n  sigma <- 1/sqrt(prec)\n  for (i in 1:nt) {\n    theta[i] ~ dnorm(mu, prec)\n  }\n  for (i in 1:nt) {\n    obsCount[i] ~ dbinom(ilogit(theta[i]), obsN[i])\n  }\n}\n\nmodelPoisson = function() {\n  alpha ~ dgamma(1, 1)\n  beta ~ dgamma(1, 1)\n  for (i in 1:nt) {\n    theta[i] ~ dgamma(alpha, beta)\n  }\n  for (i in 1:nt) {\n    obsCount[i] ~ dpois(theta[i])\n  }\n}\n\nmodelNormal = function() {\n  mu ~ dnorm(0, .001)\n  prec ~ dgamma(.001, .001)\n  sigma <- 1/sqrt(prec)\n  for (i in 1:nt) {\n    theta[i] ~ dnorm(mu, prec)\n  }\n  for (i in 1:nt) {\n    obsCount[i] ~ dnorm(theta[i], prec)\n  }\n}\n\nhierarchicalBayes = function(obs, samples = 5e3, debug = FALSE) {\n  if (all(obs <= 1 & obs >= 0)) { # Proportions: Effron / Eredivisie\n    obsCount = round(obs * 45)\n    model = modelBinom\n    obsN = rep(45, length(obsCount))\n    data.names = c('nt', 'obsCount', 'obsN')\n    handler = invLogit\n  } else {\n    handler = identity\n    obsCount = obs\n    data.names = c('nt', 'obsCount')\n    if (all(as.integer(obsCount) == obsCount)) { # Counts:  Olympics data\n      model = modelPoisson\n    } else { # simulated normal normal model\n      model = modelNormal\n    }\n  }\n  nt = length(obsCount)\n  init = list(list(theta = rep(mean(obs), nt)))\n  par = \"theta\"\n\n  capture.output(\n  res <- jags(data.names, init, par, model, n.iter = 1e3 + samples,\n             n.chains = 1, n.burnin = 1000, n.thin = 5))\n  theta.est = res$BUGSoutput$sims.list$theta\n\n  theta.est = handler(theta.est)\n  if (debug) {\n    return(res)\n  } else {\n    return(colMeans(theta.est))\n  }\n}\n\n",
    "created" : 1479288569357.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "1|76|12|0|\n15|22|29|0|\n31|55|43|0|\n45|18|47|0|\n49|23|51|0|\n54|35|56|0|\n58|37|60|0|\n63|96|92|0|\n95|38|98|0|\n100|28|112|0|\n114|30|121|0|\n124|28|129|0|\n",
    "hash" : "1430988849",
    "id" : "E268F2F8",
    "lastKnownWriteTime" : 1479294686,
    "last_content_update" : 1479294686408,
    "path" : "C:/Users/donvd/_Laptop/ResMas/Conference/TquanT/Shiny/JamesSteinRemake/functions.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}