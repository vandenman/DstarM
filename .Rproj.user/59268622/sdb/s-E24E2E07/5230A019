{
    "collab_server" : "",
    "contents" : "\\documentclass{article}\n\n%opening\n\\title{Lab Assignment Week 3: Fitzhugh-Nagumo and Izhikevich}\n\\author{Don van den Bergh \\\\ 10210199}\n\\date{}\n\n%packages\n\\usepackage{amsmath}\n\\usepackage{amssymb}\n%\\usepackage{txfonts}\n\n% preamble\n\n% remove automatic indenting\n\\newlength\\tindent\n\\setlength{\\tindent}{\\parindent}\n\\setlength{\\parindent}{0pt}\n\\renewcommand{\\indent}{\\hspace*{\\tindent}}\n\n\\newcommand{\\dxdy}[2]{\\frac{\\mathrm{d}{#1}}{\\mathrm{d}{#2}}}\n\n\n\\begin{document}\n\\maketitle\n\n<<0>>=\nlibrary(deSolve)\nlibrary(colorspace) # rainbow_hcl()\nsuppressPackageStartupMessages(library(fields))\n@\n\n\\section*{Exercise 1}\n\n<<1a>>=\ndvdr = function(x, y, params) {\n  # assuming x = v; y = r\n  dv = params[3]* (x - (1/3)*x^3 + y + params[4])\n  dr = -(1 / params[3]) * (x - params[1] + params[2]*y)\n  return(cbind(dv, dr))\n}\n@\n\n\n\\begin{equation*}\n\\begin{aligned}[c]\n\t\\dxdy{v}{t} = 0 \\Rightarrow\\, c(v - \\frac{1}{3}v^3 + r + I) &= 0 \\\\\n\tc(v - \\frac{1}{3}v^3 + I) &= -cr \\\\\n\t-(v - \\frac{1}{3}v^3 + I) &= r \\\\\n\t\\frac{1}{3}v^3 - v - I &= r \\\\\n\\end{aligned}\n\\quad  \\quad\n\\begin{aligned}[c]\n\t\\dxdy{r}{t} = 0 \\Rightarrow\\, -\\frac{1}{c}(v - a + br) &= 0 \\\\\n\t-\\frac{1}{c}(v - a) &= \\frac{b}{c}r \\\\\n\t\\frac{-(v - a)}{b} &= r \\\\\n\t\\frac{a-v}{b} &= r \\\\\n\\end{aligned}\n\\end{equation*}\nThis confirms that the two given functions are indeed nullclines.\n\n<<1b, results='asis', cache=TRUE>>=\nv_nullcline = function(v, params) (1/3)*v^3 - v - params[4]\nr_nullcline = function(v, params) (params[1] - v) / params[2]\n\n## functions for convenience -- I recycled these from assignment 2\n# make phase plot\nphasePlot = function(x, y, params = NULL) {\n  yl = ifelse(length(params) == 5, \"u\", \"r\")\n  plot(x[, 1], x[, 2], type = \"n\", las = 1,\n       bty = 'n', xlab = \"v\", ylab = yl)\n  suppressWarnings(\n    arrow.plot(x, y, arrow.ex = .05, length = .05,\n               col = \"gray\", lwd = 1, true.angle = TRUE)\n    )\n  # adds a title if parameter values are supplied\n  if (!is.null(params)) {\n    if (length(params) == 4) { # The Fitzhugh-Nagumo model, 4 parameters\n      m = sprintf(\"a = %.1f, b = %.1f, c = %.1f, I = %.1f\",\n                  params[1], params[2], params[3], params[4])\n    } else { # The Izhikevich model, 5 parameters\n      m = sprintf(\"a = %.2f, b = %.1f, c = %.1f, d = %.1f, I = %.1f\",\n                  params[1], params[2], params[3], params[4], params[5])\n    }\n    title(m)\n  }\n}\n\n# calc dvdr at all locations in allPoint for given parameters\nallDvdr = function(allPoint, params) {\n  dd = matrix(nrow = nrow(allPoint), ncol = 2)\n  for (i in 1:nrow(allPoint)) {\n    dd[i, ] = dvdr(allPoint[i, 1], allPoint[i, 2], params)\n  }\n  return(dd)\n}\n\n# use lines to add nullclines\naddNullClines = function(x, params) {\n  y_x = v_nullcline(x, params)\n  y_y = r_nullcline(x, params)\n  matlines(x, cbind(y_x, y_y), col = 2:3, lty = 1, lwd = 2)\n}\n\n# calculates and plots trajectories\n# when plot = FALSE it returns the trajectories\naddTrajectory = function(init, params,\n                         times = seq(0, 10, .01),\n                         col = rainbow_hcl(NROW(init)),\n                         plot = TRUE, ...) {\n  li = NROW(init)\n  lt = length(times)\n  res = matrix(0, lt, 2*li + 1)\n  res[, 1] = times\n  for (i in 1:li) {\n    # calc trajectory\n    tmp = suppressWarnings(\n      ode(y = c(y1 = init[i, 1], y2 = init[i, 2]),\n          func = ode_system,\n          times = times,\n          parms = params, ...)\n    )[, 2:3]\n    # sometimes ode chrashes and returns partial results\n    # this filles up the remainder with NAs so the function doesn't chrash\n    if (nrow(tmp) != lt) {\n      tmp = rbind(tmp, matrix(nrow = lt - nrow(tmp), ncol = 2))\n    }\n    # store result.\n    res[, (2:3) + 2 * (i-1)] = tmp\n  }\n\n  if (plot) {\n    idxV = seq(2, 2*li, 2)\n    idxR = idxV + 1\n    matpoints(t(init[, 1]), t(init[, 2]), pch = 19, col = col)\n    matlines(res[, idxV], res[, idxR], col = col,\n             lwd = 1.5, lty = 1)\n    return(invisible()) # avoids printing null\n  } else {\n    colnames(res) = c(\"times\", paste0(c(\"v\", \"r\"), rep(1:li, each = 2)))\n    return(res)\n  }\n}\n\node_system = function(t, state, params) {\n    return(list(dvdr(state[1], state[2], params)))\n}\n## end declaring functions\n\nv = seq(-3, 3, .3)\n# r = v\nallPoint = as.matrix(expand.grid(v, v))\n\n# finer grid to plot the nullclines on\nv2 = seq(-3, 3, .01)\n\nparams = c(.7, .8, 3, 0) # used parameters\nvecField = allDvdr(allPoint, params)\n\n# initial values for trajectories\ninits = matrix(c(2, 2, -1.5, 1.5,\n                 -1, -1, .5, -.5),\n               4, 2, byrow = TRUE)\n\nphasePlot(allPoint, vecField, params = params)\naddNullClines(v2, params)\naddTrajectory(inits, params = params)\n@\n\n\\begin{align*}\n  \\frac{a - v}{b} &= \\frac{1}{3}v^3 - v - I \\\\\n  \\frac{.7 - v}{.8} &= \\frac{1}{3}v^3 - v - 0 \\\\\n  0 &= \\frac{.8}{3}v^3 - .8v + v - .7 \\\\\n  0 &= \\frac{.8}{3}v^3 + .2v  - .7 \\tag{multiply by 3.75}\\\\\n  0 &= v^3 + \\frac{3}{4}v  - \\frac{21}{8}\n\\end{align*}\nThis is a third order polynomial. It is possible to solve this analyticaly, but that takes up quite some space for derivations. Faster is:\n\n<<1c, results='asis', cache=TRUE>>=\nff = function(v, params) v^3 + (3/4)*v - 21/8\nvO = uniroot(ff, c(-10, 10))\nrO = v_nullcline(vO$root, params)\ncat(sprintf(\"At the equilibruim v = %.6f and r = %.6f.\",\n            vO$root, rO))\n@\n\\\\ Note that this solution is obtained by applying an iterative procedure on the third order polynomial. It does not represent the exact equilibrium, but approximates it. Nonetheless, the obtained solution is equal to the given solution at the level of precision provided. The path the system takes to the equilibruim is called a ...\n\n\\section*{Exercise 2}\n\n<<2, results='asis', cache=TRUE>>=\nlv = -3 # lower v\nuv = 3  # upper v\nlr = -1 # lower r\nur = 3  # upper r\n\n# x - axis range and steps\nv = seq(lv, uv, length.out = 21)\n# y - axis range and steps\nr = seq(lr, ur, length.out = 21)\n# points to calculate vector field on\nallPoint = as.matrix(expand.grid(v, r))\n\n# finer grid to calc nullclines on\nv2 = seq(lv, uv, length.out = 1e4)\n\n# initial values for trajectories\ninits = as.matrix(expand.grid(seq(lv, uv, length.out = 3),\n                              seq(lr, ur, length.out = 3)))\n# omit center starting point\ninits = inits[-5, ]\n\n# make plot\nlayout(matrix(1:4, 2, 2, TRUE))\nfor (i in 1:4) {\n  params[4] =\n    switch(i,\n           \"1\" = -.1,\n           \"2\" = -.7,\n           \"3\" = -1.3,\n           \"4\" = -2\n    )\n  vecField = allDvdr(allPoint, params)\n  phasePlot(allPoint, vecField, params = params)\n  addNullClines(v2, params)\n  addTrajectory(inits, params = params)\n}\n@\n\nSo it seems that when I inject a negative current, the \\texttt{v\\_nullcline} moves up in the plot. As a consequence, the intersection between the nullclines changes and thus the equilibruim moves. The equilibruim changes quilitatively when it the intersection of the nullclines is inbetween the two extreme values of the \\texttt{v\\_nullcline}. If the intersection is in between the two extreme values, the equilibruim is a limit cycle. If the intersection is outside of the two extreme values, the equilibruim is a stable point. This is further illustrated in the figures below.\n\n\\section*{Exercise 3}\n\n<<3, results='asis', cache=TRUE>>=\npar(bty = 'n', las = 1, mfrow = c(2, 2))\niv = seq(2, ncol(inits)*2, 2)\nfor (i in 1:4) {\n  params[4] =\n    switch(i,\n           \"1\" = -.1,\n           \"2\" = -.7,\n           \"3\" = -1.3,\n           \"4\" = -2\n    )\n  res = addTrajectory(inits, params = params, plot = FALSE,\n                      times = seq(0, 40, .01))\n  matplot(res[, 1], res[, iv], type = 'l', lty = 1,\n          col = rainbow_hcl(length(iv)), xlab = \"t\", ylab = \"v\")\n}\n@\n\nThese figures (and their parameters) correspond to the four plots in exercise 2. These figures show that, regardless of the initial value, the voltage of the topleft and bottomright figures converges to an equilibruim. In contrast, the voltage of the topright and bottomleft figures is cyclic. This confirmes that the equilibrium is either a stable point or a limit cycle.\n\n\n% <<3, results='asis', cache=TRUE>>=\n% res = addTrajectory(inits, params = params, plot = FALSE)\n% indV = seq(2, ncol(res), 2)\n% col = rainbow_hcl(length(indV))\n% matplot(res[, 1], res[, indV], type = \"l\", lty = 1,\n%         col = col, lwd = 2, bty = 'n', las = 1,\n%         xlab = \"time\", ylab = \"v\")\n% legend(\"topright\", legend = 1:length(indV), col = col,\n%        lty = 1, lwd = 2, ncol = 2, bty = 'n')\n% @\n%\n% This corresponds to a stable spiral, although the spiraling is pretty small. It is stable, because over time all initial points converge to the same voltage. It must be a spiral because some points do overshoot; this implies that the points overshoot a little bit and then spiral towards the equilibruim.\n\n\\section*{Exercise 4}\nSince manipulating the current had no effect on type of equilibruim, I do not think that manipulating $a$ will have any effect. Instead, I will manipulate $b$ in such a way that the slope of the nullcline is suchs that there are two intersections between the nullclines. That way, I know for sure that something changes.\n\n<<4a, results='asis', cache=TRUE>>=\nv = seq(-3, 3, .3)\n# points to calculate vector field on\nallPoint = as.matrix(expand.grid(v, v))\n\n# finer grid to plot the nullclines on\nv2 = seq(-3, 3, .01)\n\nparams = c(.7, -2, 3, 0) # b is now -2\nvecField = allDvdr(allPoint, params)\n\n# initial values for trajectories\ninits = as.matrix(expand.grid(seq(-2, 2, 1),\n                              seq(-2, 2, 1)))\n\n# make plot\nphasePlot(allPoint, vecField, params = params)\naddNullClines(v2, params)\naddTrajectory(inits, params = params)\n\n@\n\nNow we have three equilibria: 1) left intersection of nullclines, a saddle point. 2) middle intersection of nullclines, an unstable node. 3) right intersection of nullclines, a saddle point. This is further illustrated below.\n\n<<4b, results='asis', cache=TRUE>>=\nres = addTrajectory(inits, params = params, plot = FALSE)\nindV = seq(2, ncol(res), 2)\ncol = rainbow_hcl(length(indV))\nlayout(matrix(1:2, 1, 2))\nmatplot(res[, 1], res[, indV], type = \"l\", lty = 1,\n        col = col, lwd = 2, bty = 'n', ylim = c(-8, 10),\n        xlab = \"time\", ylab = \"v\", yaxt = \"n\")\naxis(2, at = seq(-8, 10, 2), las = 1)\nmatplot(res[, 1], res[, indV+1], type = \"l\", lty = 1,\n        col = col, lwd = 2, bty = 'n', las = 1,\n        xlab = \"time\", ylab = \"r\")\n@\n\nIn the left plot, it is clear that lines initially approach -2 or 2 (the saddle points) and then shoot off towards either $+\\infty$ or $-\\infty$. Some lines first approach one saddle point and then approach the other, before shooting of to $+\\infty$ or $-\\infty$. This switch in direction happens when trajectories enter the area encapsulated by both nullclines.\n\n\\section*{The Izhikevich model: Exercise 5}\n\n<<5a, results='asis', cache=FALSE>>=\n# I am renaming u to r. That way, most of the\n# functions used before don't break\n# params = c(a, b, c, d, I)\ndvdr = function(x, y, params) {\n  # assuming x = v; y = u\n  # reset condition\n    if (x >= 30) {\n        x = params[3]\n        y = y + params[4]\n    }\n  dv = .04*x^2 + 5*x + 140 - y + params[5]\n  dr = params[1] * (params[2] * x - y)\n  return(cbind(dv, dr))\n}\n\nv_nullcline = function(v, params) .04*v^2 + 5*v + 140 + params[5]\nr_nullcline = function(v, params) params[2] * v\n\n# root function\nroot = function(t, state, params) return(state[1] - 30)\n\n# event function\nevent = function(t, state, params) {\n\tv = params[3]\n\tu = state[2] + params[4]\n\treturn(c(v, u))\n}\n\n# time 1 sec by 1ms, like in the paper\ntime = seq(0, 30, .01)\n\nlv = -100\nuv = 30\nlu = -40\nuu = 20\n\nv = seq(lv, uv, length.out = 21)\nu = seq(lu, uu, length.out = 21)\n# points to calculate vector field on\nallPoint = as.matrix(expand.grid(v, u))\n\n# finer grid to plot the nullclines on\nv2 = seq(lv, uv, length.out = 1e4)\n\n# param config for regular spiking\nparams = c(.02, .2, -65, 8, 10)\nvecField = allDvdr(allPoint, params)\n\n# initial values for trajectories\ninits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),\n                              seq(lu, uu, length.out = 4)))\n\n# make plot\nlayout(1)\nphasePlot(allPoint, vecField, params = params)\naddNullClines(v2, params)\naddTrajectory(inits, params = params, rootfun = root,\n              events = list(func = event, root = TRUE))\n\nres = addTrajectory(inits, params = params,\n                    times = time, plot = FALSE,\n                    events = list(func = event, root = TRUE),\n                    rootfun=root)\nindV = seq(2, ncol(res), 2)\nii1 = 1:6\nii2 = 7:12\ncol = rainbow_hcl(length(indV))\npar(bty = 'n', las = 1, lwd = 2, lty = 1, mfrow = c(2, 2))\nmatplot(res[, 1], res[, indV[ii1]], type = \"l\",lty = 1,\n        col = col[ii1], xlab = \"time\", ylab = \"v\")\nmatplot(res[, 1], res[, indV[ii1]+1], type = \"l\", lty = 1,\n        col = col[ii1], xlab = \"time\", ylab = \"u\")\nmatplot(res[, 1], res[, indV[ii2]], type = \"l\", lty = 1,\n        col = col[ii2], xlab = \"time\", ylab = \"v\")\nmatplot(res[, 1], res[, indV[ii2]+1], type = \"l\", lty = 1,\n        col = col[ii2], lwd = 2, xlab = \"time\", ylab = \"u\")\n@\n\n<<5b, results='asis', cache=FALSE>>=\n# param config for fast spiking\nparams = c(.1, .2, -65, 2, 10)\nvecField = allDvdr(allPoint, params)\n\n# make plot\nlayout(1)\nphasePlot(allPoint, vecField, params = params)\naddNullClines(v2, params)\naddTrajectory(inits, params = params, rootfun = root,\n              events = list(func = event, root = TRUE))\n\nres = addTrajectory(inits, params = params,\n                    times = time, plot = FALSE,\n                    events = list(func = event, root = TRUE),\n                    rootfun=root)\n\npar(bty = 'n', las = 1, lwd = 2, lty = 1, mfrow = c(2, 2))\nmatplot(res[, 1], res[, indV[ii1]], type = \"l\",lty = 1,\n        col = col[ii1], xlab = \"time\", ylab = \"v\")\nmatplot(res[, 1], res[, indV[ii1]+1], type = \"l\", lty = 1,\n        col = col[ii1], xlab = \"time\", ylab = \"u\")\nmatplot(res[, 1], res[, indV[ii2]], type = \"l\", lty = 1,\n        col = col[ii2], xlab = \"time\", ylab = \"v\")\nmatplot(res[, 1], res[, indV[ii2]+1], type = \"l\", lty = 1,\n        col = col[ii2], lwd = 2, xlab = \"time\", ylab = \"u\")\n@\n\n<<5c, results='asis', cache=FALSE>>=\n# param config for intrinsically bursting\nparams = c(.02, .2, -55, 4, 10)\nvecField = allDvdr(allPoint, params)\n\n# make plot\nlayout(1)\nphasePlot(allPoint, vecField, params = params)\naddNullClines(v2, params)\naddTrajectory(inits, params = params, rootfun = root,\n              events = list(func = event, root = TRUE))\n\nres = addTrajectory(inits, params = params,\n                    times = time, plot = FALSE,\n                    events = list(func = event, root = TRUE),\n                    rootfun = root)\n\npar(bty = 'n', las = 1, lwd = 2, lty = 1, mfrow = c(2, 2))\nmatplot(res[, 1], res[, indV[ii1]], type = \"l\",lty = 1,\n        col = col[ii1], xlab = \"time\", ylab = \"v\")\nmatplot(res[, 1], res[, indV[ii1]+1], type = \"l\", lty = 1,\n        col = col[ii1], xlab = \"time\", ylab = \"u\")\nmatplot(res[, 1], res[, indV[ii2]], type = \"l\", lty = 1,\n        col = col[ii2], xlab = \"time\", ylab = \"v\")\nmatplot(res[, 1], res[, indV[ii2]+1], type = \"l\", lty = 1,\n        col = col[ii2], lwd = 2, xlab = \"time\", ylab = \"u\")\n@\n\n\\end{document}\n",
    "created" : 1479213220505.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2485518667",
    "id" : "5230A019",
    "lastKnownWriteTime" : 1479297972,
    "last_content_update" : 1479297972449,
    "path" : "C:/Users/donvd/_Laptop/ResMas/Foundations of Neural and Cognitive Modelling/Homework/3/homework3.Rnw",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "sweave"
}