ni = 4
dat1 = rmvbin(np, rep(1/ni, ni), bincorr = cor1)
cor_auto(dat1)
cor1
dat2 = rmvbin(np, rep(1/ni, ni), bincorr = cor2)
dat1 = rmvbin(np, margprob = rep(1/ni, ni), bincorr = cor1)
dat2 = rmvbin(np, margprob = rep(1/ni, ni), bincorr = cor2)
m <- cbind(c(1/2,1/5,1/6),c(1/5,1/2,1/6),c(1/6,1/6,1/2))
m
dat1 = rmvbin(np, bincorr = cor1)
dat1 = rmvbin(np, commonprob =  = cor1)
dat1 = rmvbin(np, commonprob = cor1)
cor1
library(MASS)
d1 = mvrnorm(np, rep(0, ni), cor1)
d2 = mvrnorm(np, rep(0, ni), cor2)
d1 = mvrnorm(np, rep(0, ni), cor1)
d2 = mvrnorm(np, rep(0, ni), cor2)
d1 = as.numeric(d1 >= 0)
d2 = as.numeric(d2 >= 0)
cor_auto(d1)
d1
d1 = mvrnorm(np, rep(0, ni), cor1)
d2 = mvrnorm(np, rep(0, ni), cor2)
d1 >= 0
1*(d1 >= 0)
d2 = 1*(d2 >= 0)
cor_auto(d1)
cor1
np = 1e5
ni = 4
library(MASS)
d1 = mvrnorm(np, rep(0, ni), cor1)
d2 = mvrnorm(np, rep(0, ni), cor2)
d1 = 1*(d1 >= 0)
d2 = 1*(d2 >= 0)
cor_auto(d1)
cor1
cor_auto(d2)
cor2
layout(matrix(1:2, 1, 2))
q1 = qgraph(cor1, layout = "spring")
q2 = qgraph(cor2, layout = q1$layout)
np = 1e2
ni = 4
library(MASS)
d1 = mvrnorm(np, rep(0, ni), cor1)
d2 = mvrnorm(np, rep(0, ni), cor2)
d1 = 1*(d1 >= 0)
d2 = 1*(d2 >= 0)
dat = rbind(d1, d2)
cor(dat)
cor1 + cor2 / 2
cor1 + cor2
(cor1 + cor2) / 2
cor(dat)
np = 1e5
ni = 4
library(MASS)
d1 = mvrnorm(np, rep(0, ni), cor1)
d2 = mvrnorm(np, rep(0, ni), cor2)
d1 = 1*(d1 >= 0)
d2 = 1*(d2 >= 0)
dat = rbind(d1, d2)
cor(dat)
(cor1 + cor2) / 2
mean(rowSums(d1))
mean(rowSums(d2))
cor_auto(d1)
cor_auto(d2)
c1 = cor_auto(d1)
c2 = cor_auto(d2)
c1
c2
cor(dat)
(cor1 + cor2) / 2
cAll = cor_auto(dat)
dat = rbind(d1, d2)
cAll = cor_auto(dat)
cAll
colMeans(d1)
colMeans(d2)
mean(rowSums(d1))
mean(rowSums(d2))
var(rowSums(d1))
var(rowSums(d2))
library(randomForest)
rf = randomForest(x = dat)
i1 = sample(1:np, floor(.01*np))
i2 = sample(1:np, floor(.01*np))
datRf = rbind(d1[i1], d2[i2])
rf = randomForest(x = datRf)
rf
rf$predicted
rf$type
cctscree(dat)
np = 1e3
ni = 4
library(MASS)
d1 = mvrnorm(np, rep(0, ni), cor1)
d2 = mvrnorm(np, rep(0, ni), cor2)
d1 = 1*(d1 >= 0)
d2 = 1*(d2 >= 0)
c1 = cor_auto(d1)
c2 = cor_auto(d2)
dat = rbind(d1, d2)
cAll = cor_auto(dat)
colMeans(d1)
colMeans(d2)
mean(rowSums(d1))
mean(rowSums(d2))
var(rowSums(d1))
var(rowSums(d2))
rf = randomForest(x = dat)
cctscree(dat)
rm(list = ls())
library(DstarM)
wd = "C:/Users/donvd/_Laptop/ResMas/Internship/DstarM/massSimulation/Simulation/EJ2/onePerson/"
setwd(wd)
# Data cleaning -----
data(speed_acc, package = "rtdists") # load complete dataset (requires package rtdists)
# data cleaning copied from help('speed_acc')
speed_acc = droplevels(speed_acc[!speed_acc$censor,]) # remove excluded trials
# new factors for obtaining values as in Table 1, Wagenmakers et al. (2008, p. 152)
speed_acc$freq = with(speed_acc,
factor(ifelse(stim_cat == "nonword", "nonword",
as.character(frequency)),
levels = c("high", "low", "very_low", "nonword")))
# end of copied code
response = speed_acc$response # extract response
condition1 = speed_acc$condition # extract condition
rt = speed_acc$rt # extract rt
pp = speed_acc$id # extract pp ids
condition2 = speed_acc$freq # extract word category
condition = paste(condition1, condition2) # all conditions
# combine all relevant variables in one dataset
dat.all = data.frame(response = response, condition = condition,
rt = rt, pp = pp, condition2 = condition2)
head(dat.all)
# for the purpose of this tutorial we only use participant 1
dat = dat.all[dat.all$pp == 1, ]
# descriptives of the data
rtDescriptives(dat)
# histograms of observed data
# x11() # try this if "Error in plot.new() : figure margins too large" occurs
rtHist(dat)
# recode word to upper and nonword to lower this is not required,
# but otherwise the recoding is done alphabetically.
# THen, "word" is coded as lower and estimated drift speeds will be negative.
dat$response = ifelse(dat$response == "word", "upper", "lower")
# Analysis -----
# time grid
tt = seq(0, 5, .01)
restrTrad = matrix(1:7, 7, 8)
restrTrad[1, 5:8] = 8 # release boundary across speed-accuracy condition
restrTrad[2, ] = c(2, 9:11) # release drift speeds across word frequency conditions
restrTrad[4, 5:8] = 12 # release starting point across speed-accuracy condition
pi
resDstarM2 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = .9,
DstarM = TRUE, Optim = list(parallelType = 1))
restrDstarM = restrTrad[c(1:2, 4:6), ]
resDstarM2 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = .9,
DstarM = TRUE, Optim = list(parallelType = 1))
restrTrad[2, ] = c(2, 9:11) # release drift speeds across word frequency conditions
resND1 = estND(res = resDstarM1, tt = ttND, data = dat,
Optim = list(parallelType = 1))
# do traditional analysis
resTraditional1 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
set.seed(pi) # reproducibility
# do traditional analysis
resTraditional1 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
resTraditional2 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
resTraditional3 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
resTraditional4 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
resTraditional5 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
# restriction matrix for DstarM analysis
restrDstarM = restrTrad[c(1:2, 4:6), ]
# do DstarM analysis
resDstarM1 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = 1,
DstarM = TRUE, Optim = list(parallelType = 1))
resDstarM2 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = .9,
DstarM = TRUE, Optim = list(parallelType = 1))
resDstarM3 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = .8,
DstarM = TRUE, Optim = list(parallelType = 1))
resDstarM4 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = .7,
DstarM = TRUE, Optim = list(parallelType = 1))
rm(list = ls())
library(DstarM)
wd = "C:/Users/donvd/_Laptop/ResMas/Internship/DstarM/massSimulation/Simulation/EJ2/onePerson/"
setwd(wd)
# Data cleaning -----
data(speed_acc, package = "rtdists") # load complete dataset (requires package rtdists)
# data cleaning copied from help('speed_acc')
speed_acc = droplevels(speed_acc[!speed_acc$censor,]) # remove excluded trials
# new factors for obtaining values as in Table 1, Wagenmakers et al. (2008, p. 152)
speed_acc$freq = with(speed_acc,
factor(ifelse(stim_cat == "nonword", "nonword",
as.character(frequency)),
levels = c("high", "low", "very_low", "nonword")))
# end of copied code
response = speed_acc$response # extract response
condition1 = speed_acc$condition # extract condition
rt = speed_acc$rt # extract rt
pp = speed_acc$id # extract pp ids
condition2 = speed_acc$freq # extract word category
condition = paste(condition1, condition2) # all conditions
# combine all relevant variables in one dataset
dat.all = data.frame(response = response, condition = condition,
rt = rt, pp = pp, condition2 = condition2)
head(dat.all)
# for the purpose of this tutorial we only use participant 1
dat = dat.all[dat.all$pp == 1, ]
# descriptives of the data
rtDescriptives(dat)
# histograms of observed data
# x11() # try this if "Error in plot.new() : figure margins too large" occurs
rtHist(dat)
# recode word to upper and nonword to lower this is not required,
# but otherwise the recoding is done alphabetically.
# THen, "word" is coded as lower and estimated drift speeds will be negative.
dat$response = ifelse(dat$response == "word", "upper", "lower")
# Analysis -----
# time grid
tt = seq(0, 5, .01)
# restriction matrix for traditional analysis
restrTrad = matrix(1:7, 7, 8)
restrTrad[1, 5:8] = 8 # release boundary across speed-accuracy condition
restrTrad[2, ] = c(2, 9:11) # release drift speeds across word frequency conditions
restrTrad[4, 5:8] = 12 # release starting point across speed-accuracy condition
set.seed(pi) # reproducibility
# do traditional analysis
resTraditional1 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
resTraditional2 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
resTraditional3 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
resTraditional4 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
resTraditional5 = estDstarM(data = dat, tt = tt, restr = restrTrad,
DstarM = FALSE, Optim = list(parallelType = 1))
# restriction matrix for DstarM analysis
restrDstarM = restrTrad[c(1:2, 4:6), ]
# do DstarM analysis
resDstarM1 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = 1.2,
DstarM = TRUE, Optim = list(parallelType = 1))
resDstarM2 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = 1.1,
DstarM = TRUE, Optim = list(parallelType = 1))
resDstarM3 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = 1.0,
DstarM = TRUE, Optim = list(parallelType = 1))
resDstarM4 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = 0.9,
DstarM = TRUE, Optim = list(parallelType = 1))
resDstarM5 = estDstarM(data = dat, tt = tt, restr = restrDstarM, h = 0.8,
DstarM = TRUE, Optim = list(parallelType = 1))
# Estimate nondecision distribution
ttND = seq(0, 5, .05) # slightly smoother time grid
resND1 = estND(res = resDstarM1, tt = ttND, data = dat,
Optim = list(parallelType = 1))
resND2 = estND(res = resDstarM2, tt = ttND, data = dat,
Optim = list(parallelType = 1))
resND3 = estND(res = resDstarM3, tt = ttND, data = dat,
Optim = list(parallelType = 1))
resND4 = estND(res = resDstarM4, tt = ttND, data = dat,
Optim = list(parallelType = 1))
resND5 = estND(res = resDstarM5, tt = ttND, data = dat,
Optim = list(parallelType = 1))
allResults5 = list(
resTraditional = list(
resTraditional1 = resTraditional1,
resTraditional2 = resTraditional2,
resTraditional3 = resTraditional3,
resTraditional4 = resTraditional4,
resTraditional5 = resTraditional5),
resDstarM = list(
resDstarM1 = resDstarM1,
resDstarM2 = resDstarM2,
resDstarM3 = resDstarM3,
resDstarM4 = resDstarM4,
resDstarM5 = resDstarM5),
resND = list(
resND1 = resND1,
resND2 = resND2,
resND3 = resND3,
resND4 = resND4,
resND5 = resND5))
save(allResults5, file = "allResults5.Rdata")
resTraditional = allResults5$resTraditional
resDstarM = allResults5$resDstarM
resND = allResults5$resND
ttND = seq(0, 5, .05)
obsTraditional = lapply(resTraditional, estObserved, data = dat)
names(obsTraditional) = paste0("obsTraditional", 1:length(qq))
# calculate observed densities and fit measures for DstarM models
obsDstarM = Map(estObserved,
resDecision = resDstarM,
resND = resND,
data = list(dat))
names(obsDstarM) = paste("obsDstarM", 1:length(obsDstarM))
chisqFitTraditional = sapply(obsTraditional, function(x) x$fit$chisq$sum)
chisqFitDstarM = sapply(obsDstarM, function(x) x$fit$chisq$sum)
chisqFitDstarM
chisqFitTraditional
resNDB1 = estND(res = resDstarM1, Optim = list(parallelType = 1))
resNDB2 = estND(res = resDstarM2, Optim = list(parallelType = 1))
resNDB3 = estND(res = resDstarM3, Optim = list(parallelType = 1))
resNDB4 = estND(res = resDstarM4, Optim = list(parallelType = 1))
resNDB5 = estND(res = resDstarM5, Optim = list(parallelType = 1))
allResults5 = list(
resTraditional = list(
resTraditional1 = resTraditional1,
resTraditional2 = resTraditional2,
resTraditional3 = resTraditional3,
resTraditional4 = resTraditional4,
resTraditional5 = resTraditional5),
resDstarM = list(
resDstarM1 = resDstarM1,
resDstarM2 = resDstarM2,
resDstarM3 = resDstarM3,
resDstarM4 = resDstarM4,
resDstarM5 = resDstarM5),
resND = list(
resND1 = resND1,
resND2 = resND2,
resND3 = resND3,
resND4 = resND4,
resND5 = resND5),
resNDB = list(
resND1 = resNDB1,
resND2 = resNDB2,
resND3 = resNDB3,
resND4 = resNDB4,
resND5 = resNDB5))
save(allResults5, file = "allResults5.Rdata")
resNDB = allResults5$resNDB
obsDstarMB = Map(estObserved,
resDecision = resDstarM,
resND = resNDB,
data = list(dat))
names(obsDstarMB) = paste("obsDstarMB", 1:length(obsDstarM))
chisqFitTraditional = sapply(obsTraditional, function(x) x$fit$chisq$sum)
chisqFitDstarM = sapply(obsDstarM, function(x) x$fit$chisq$sum)
chisqFitDstarMB = sapply(obsDstarMB, function(x) x$fit$chisq$sum)
chisqFitDstarMB
chisqFitDstarM
library(Cairo) # for exporting figures
library(colorspace) # for colors
BestTraditional = which.min(chisqFitTraditional)
BestDstarM = which.min(chisqFitDstarM)
obsT = obsTraditional[[BestTraditional]]
obsD = obsDstarM[[BestDstarM]]
resT = resTraditional[[BestTraditional]]
resD = resDstarM[[BestDstarM]]
resN = resND[[BestDstarM]]
parList = list(cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.3,
mar = c(5, 6, 4, 5) + 0.1, mgp = c(3.5, 1, 0),
font.lab = 2, lwd = 3, bty = 'n', las = 1)
# plot of nondecision distribution, decision distribution,
# and total distribution.
tradPars = coef(resT)[restrTrad]
dim(tradPars) = dim(restrTrad)
tradNdPars = tradPars[c(3, 7), 1]
# convert mean and range to lower and upper
ab = tradNdPars[1] + tradNdPars[2] %*% c(-1, 1)
# We omit the nondecision parameters from the
# traditional model and calculate the model pdfs
tradDecPars = tradPars[-c(3, 7), ]
tradDecModUp = matrix(nrow = length(tt), ncol = ncol(tradDecPars))
tradDecModLo = matrix(nrow = length(tt), ncol = ncol(tradDecPars))
for (i in 1:ncol(tradDecModUp)) {
tradDecModUp[, i] = Voss.density(tt, tradDecPars[, i], boundary = "upper", TRUE)
tradDecModLo[, i] = Voss.density(tt, tradDecPars[, i], boundary = "lower", TRUE)
}
tradDecMod = cbind(tradDecModLo[, 5:8],
tradDecModUp[, 5:8],
tradDecModLo[, 1:4],
tradDecModUp[, 1:4])
colnames(tradDecMod) = colnames(resT$modelDist)
# plot nondecision model
plot(resND2, xlim = c(.2, .6), col = col[1], lwd = lwd)
lines(tt, dunif(tt, ab[1], ab[2]), type = 'b', col = col[2], lwd = lwd)
legend("topright", c("DstarM", "Traditional"),
col = col, pch = 21, lty = 1, bty = 'n',
pt.bg = 0, lwd = lwd)
plot(resN, xlim = c(.2, .6), col = col[1], lwd = lwd)
lines(tt, dunif(tt, ab[1], ab[2]), type = 'b', col = col[2], lwd = lwd)
legend("topright", c("DstarM", "Traditional"),
col = col, pch = 21, lty = 1, bty = 'n',
pt.bg = 0, lwd = lwd)
resN
plot(resN, xlim = c(.2, .6), col = col[1], lwd = lwd)
resN
plot(resN)
col
oldPar = par()
col = colorspace::rainbow_hcl(2)
parList = list(cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.3,
mar = c(5, 6, 4, 5) + 0.1, mgp = c(3.5, 1, 0),
font.lab = 2, lwd = 3, bty = 'n', las = 1)
# plot of nondecision distribution, decision distribution,
# and total distribution.
tradPars = coef(resT)[restrTrad]
dim(tradPars) = dim(restrTrad)
tradNdPars = tradPars[c(3, 7), 1]
# convert mean and range to lower and upper
ab = tradNdPars[1] + tradNdPars[2] %*% c(-1, 1)
# We omit the nondecision parameters from the
# traditional model and calculate the model pdfs
tradDecPars = tradPars[-c(3, 7), ]
tradDecModUp = matrix(nrow = length(tt), ncol = ncol(tradDecPars))
tradDecModLo = matrix(nrow = length(tt), ncol = ncol(tradDecPars))
for (i in 1:ncol(tradDecModUp)) {
tradDecModUp[, i] = Voss.density(tt, tradDecPars[, i], boundary = "upper", TRUE)
tradDecModLo[, i] = Voss.density(tt, tradDecPars[, i], boundary = "lower", TRUE)
}
tradDecMod = cbind(tradDecModLo[, 5:8],
tradDecModUp[, 5:8],
tradDecModLo[, 1:4],
tradDecModUp[, 1:4])
colnames(tradDecMod) = colnames(resT$modelDist)
# plot nondecision model
plot(resN, xlim = c(.2, .6), col = col[1], lwd = lwd)
lines(tt, dunif(tt, ab[1], ab[2]), type = 'b', col = col[2], lwd = lwd)
legend("topright", c("DstarM", "Traditional"),
col = col, pch = 21, lty = 1, bty = 'n',
pt.bg = 0, lwd = lwd)
oldPar = par()
col = colorspace::rainbow_hcl(2)
# some graphical options for the figures
parList = list(cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.3,
mar = c(5, 6, 4, 5) + 0.1, mgp = c(3.5, 1, 0),
font.lab = 2, lwd = 3, bty = 'n', las = 1)
# plot of nondecision distribution, decision distribution,
# and total distribution.
tradPars = coef(resT)[restrTrad]
dim(tradPars) = dim(restrTrad)
tradNdPars = tradPars[c(3, 7), 1]
# convert mean and range to lower and upper
ab = tradNdPars[1] + tradNdPars[2] %*% c(-1, 1)
# We omit the nondecision parameters from the
# traditional model and calculate the model pdfs
tradDecPars = tradPars[-c(3, 7), ]
tradDecModUp = matrix(nrow = length(tt), ncol = ncol(tradDecPars))
tradDecModLo = matrix(nrow = length(tt), ncol = ncol(tradDecPars))
for (i in 1:ncol(tradDecModUp)) {
tradDecModUp[, i] = Voss.density(tt, tradDecPars[, i], boundary = "upper", TRUE)
tradDecModLo[, i] = Voss.density(tt, tradDecPars[, i], boundary = "lower", TRUE)
}
tradDecMod = cbind(tradDecModLo[, 5:8],
tradDecModUp[, 5:8],
tradDecModLo[, 1:4],
tradDecModUp[, 1:4])
colnames(tradDecMod) = colnames(resT$modelDist)
col
plot(resN, xlim = c(.2, .6), col = col[1], lwd = lwd)
plot(resN, xlim = c(.2, .6), col = col[1])
lwd = 3
plot(resN, xlim = c(.2, .6), col = col[1], lwd = lwd)
lines(tt, dunif(tt, ab[1], ab[2]), type = 'b', col = col[2], lwd = lwd)
legend("topright", c("DstarM", "Traditional"),
col = col, pch = 21, lty = 1, bty = 'n',
pt.bg = 0, lwd = lwd)
cdfT = estCdf(obsT)
cdfD = estCdf(obsD)
probs = seq(0, 1, .01)
qqT = estQdf(p = probs, x = tt, cdf = cdfT)
qqD = estQdf(p = probs, x = ttND, cdf = cdfD)
obsQ = obsQuantiles(dat, probs = probs)
qqT = qqT[-c(1, length(probs)), ]
qqD = qqD[-c(1, length(probs)), ]
obsQ = obsQ[-c(1, length(probs)), ]
pp = rep(1, nrow(qqT))
pp[seq(10, length(pp), 10)] = 18
pp2 = ifelse(pp == 1, .7, 1.4)
titles2 = paste("Condition:", c("Acc", "Spd"))
titles2 = paste0(rep(titles2, each = 8), " ",
rep(c("HF", "LF", "NW", "VLF"), each = 2), "\n")
titles2 = paste0(titles2, "Response: ", c("Nonword", "Word"))
sampleSizes = tapply(dat$rt, list(dat$condition, dat$response), length)
sampleSizes = c(t(sampleSizes))
titles2 = paste0(titles2, " (N = ", sampleSizes, ")")
x11()
par(parList)
layout(matrix(1:16, 4, 4, TRUE))
for (i in 1:16) {
yr = range(c(qqT[, i], qqD[, i]))
xr = range(obsQ[, i])
# empty plot with abline indicating perfect fit
plot(c(0, 10), c(0, 10), type = 'l', lwd = 1,
xlim = xr, ylim = yr,
xlab = "Observed", ylab = "Model implied")
# plot Traditional quantiles
lines(obsQ[, i], qqT[, i], type = 'b',
lty = 1, col = col[1], pch = pp,
lwd = pp, ylim = yr, cex = pp2)
# add DstarM quantiles
lines(obsQ[, i], qqD[, i], type = 'b',
lty = 1, col = col[2], pch = pp,
lwd = pp, ylim = yr, cex = pp2)
# add a title
title(titles2[i])
# add a legend in the first plot
if (i == 1) {
legend("topleft", c("Traditional", "D*M"),
lty = 0, pch = 1, bty = 'n', col = col, cex = 2)
}
}
