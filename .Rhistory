indV = seq(2, ncol(res), 2)
col = rainbow_hcl(length(indV))
par(bty = 'n', las = 1, lwd = 2, lty = 1,
mfrow = c(2, 2))
matplot(res[, 1], res[, indV[1:4]], type = "l",lty = 1,
col = col[1:4], xlab = "time", ylab = "v")
matplot(res[, 1], res[, indV[1:4]+1], type = "l", lty = 1,
col = col[1:4], xlab = "time", ylab = "u")
matplot(res[, 1], res[, indV[5:9]], type = "l", lty = 1,
col = col[5:9], xlab = "time", ylab = "v")
matplot(res[, 1], res[, indV[5:9]+1], type = "l", lty = 1,
col = col[5:9], lwd = 2, xlab = "time", ylab = "u")
params = c(.1, .2, -65, 2, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
params
warnings()
dvdr = function(x, y, params) {
# assuming x = v; y = u
# reset condition
if (x >= 30) {
x = params[3]
y = y + params[4]
}
dv = .04*x^2 + 5*x + 140 - y + params[5]
dr = params[1] * (params[2] * x - y)
return(cbind(dv, dr))
}
v_nullcline = function(v, params) .04*v^2 + 5*v + 140 + params[5]
r_nullcline = function(v, params) params[2] * v
# root function
root = function(t, state, params) return(state[1] - 30)
# event function
event = function(t, state, params) {
v = params[3]
u = state[2] + params[4]
return(c(v, u))
}
# time 1 sec by 1ms, like in the paper
time = seq(0, 20, .01)
lv = -100
uv = 30
lu = -40
uu = 20
v = seq(lv, uv, length.out = 21)
u = seq(lu, uu, length.out = 21)
# points to calculate vector field on
allPoint = as.matrix(expand.grid(v, u))
# finer grid to plot the nullclines on
v2 = seq(lv, uv, length.out = 1e4)
# param config for regular spiking
params = c(.02, .2, -65, 8, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
params = c(.02, .2, -65, 8, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
layout(1)
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
params
addNullClines
# Chunk 1: 0
library(deSolve)
library(colorspace) # rainbow_hcl()
suppressPackageStartupMessages(library(fields))
# Chunk 2: 1a
dvdr = function(x, y, params) {
# assuming x = v; y = r
dv = params[3]* (x - (1/3)*x^3 + y + params[4])
dr = -(1 / params[3]) * (x - params[1] + params[2]*y)
return(cbind(dv, dr))
}
# Chunk 3: 1b
v_nullcline = function(v, params) (1/3)*v^3 - v - params[4]
r_nullcline = function(v, params) (params[1] - v) / params[2]
## functions for convenience -- I recycled these from assignment 2
# make phase plot
phasePlot = function(x, y, params = NULL) {
yl = ifelse(length(params) == 5, "u", "r")
plot(x[, 1], x[, 2], type = "n", las = 1,
bty = 'n', xlab = "v", ylab = yl)
suppressWarnings(
arrow.plot(x, y, arrow.ex = .05, length = .05,
col = "gray", lwd = 1, true.angle = TRUE)
)
# adds a title if parameter values are supplied
if (!is.null(params)) {
if (length(params) == 4) { # The Fitzhugh-Nagumo model, 4 parameters
m = sprintf("a = %.1f, b = %.1f, c = %.1f, I = %.1f",
params[1], params[2], params[3], params[4])
} else { # The Izhikevich model, 5 parameters
m = sprintf("a = %.2f, b = %.1f, c = %.1f, d = %.1f, I = %.1f",
params[1], params[2], params[3], params[4], params[5])
}
title(m)
}
}
# calc dvdr at all locations in allPoint for given parameters
allDvdr = function(allPoint, params) {
dd = matrix(nrow = nrow(allPoint), ncol = 2)
for (i in 1:nrow(allPoint)) {
dd[i, ] = dvdr(allPoint[i, 1], allPoint[i, 2], params)
}
return(dd)
}
# use lines to add nullclines
addNullClines = function(x, params) {
y_x = v_nullcline(x, params)
y_y = r_nullcline(x, params)
matlines(x, cbind(y_x, y_y), col = 2:3, lty = 1, lwd = 2)
}
# calculates and plots trajectories
# when plot = FALSE it returns the trajectories
addTrajectory = function(init, params,
times = seq(0, 10, .01),
col = rainbow_hcl(NROW(init)),
plot = TRUE, ...) {
li = NROW(init)
lt = length(times)
res = matrix(0, lt, 2*li + 1)
res[, 1] = times
for (i in 1:li) {
# calc trajectory
tmp = suppressWarnings(
ode(y = c(y1 = init[i, 1], y2 = init[i, 2]),
func = ode_system,
times = times,
parms = params, ...)
)[, 2:3]
# sometimes ode chrashes and returns partial results
# this filles up the remainder with NAs so the function doesn't chrash
if (nrow(tmp) != lt) {
tmp = rbind(tmp, matrix(nrow = lt - nrow(tmp), ncol = 2))
}
# store result.
res[, (2:3) + 2 * (i-1)] = tmp
}
if (plot) {
idxV = seq(2, 2*li, 2)
idxR = idxV + 1
matpoints(t(init[, 1]), t(init[, 2]), pch = 19, col = col)
matlines(res[, idxV], res[, idxR], col = col,
lwd = 1.5, lty = 1)
return(invisible()) # avoids printing null
} else {
colnames(res) = c("times", paste0(c("v", "r"), rep(1:li, each = 2)))
return(res)
}
}
ode_system = function(t, state, params) {
return(list(dvdr(state[1], state[2], params)))
}
## end declaring functions
v = seq(-3, 3, .3)
# r = v
allPoint = as.matrix(expand.grid(v, v))
# finer grid to plot the nullclines on
v2 = seq(-3, 3, .01)
params = c(.7, .8, 3, 0) # used parameters
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = matrix(c(2, 2, -1.5, 1.5,
-1, -1, .5, -.5),
4, 2, byrow = TRUE)
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params)
# Chunk 4: 1c
ff = function(v, params) v^3 + (3/4)*v - 21/8
vO = uniroot(ff, c(-10, 10))
rO = v_nullcline(vO$root, params)
cat(sprintf("At the equilibruim v = %.6f and r = %.6f.",
vO$root, rO))
# Chunk 5: 2
lv = -3 # lower v
uv = 3  # upper v
lr = -1 # lower r
ur = 3  # upper r
# x - axis range and steps
v = seq(lv, uv, length.out = 21)
# y - axis range and steps
r = seq(lr, ur, length.out = 21)
# points to calculate vector field on
allPoint = as.matrix(expand.grid(v, r))
# finer grid to calc nullclines on
v2 = seq(lv, uv, length.out = 1e4)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, uv, length.out = 3),
seq(lr, ur, length.out = 3)))
# omit center starting point
inits = inits[-5, ]
# make plot
layout(matrix(1:4, 2, 2, TRUE))
for (i in 1:4) {
params[4] =
switch(i,
"1" = -.1,
"2" = -.7,
"3" = -1.3,
"4" = -2
)
vecField = allDvdr(allPoint, params)
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params)
}
# Chunk 6: 3
par(bty = 'n', las = 1, mfrow = c(2, 2))
iv = seq(2, ncol(inits)*2, 2)
for (i in 1:4) {
params[4] =
switch(i,
"1" = -.1,
"2" = -.7,
"3" = -1.3,
"4" = -2
)
res = addTrajectory(inits, params = params, plot = FALSE,
times = seq(0, 40, .01))
matplot(res[, 1], res[, iv], type = 'l', lty = 1,
col = rainbow_hcl(length(iv)), xlab = "t", ylab = "v")
}
# Chunk 7: 4a
v = seq(-3, 3, .3)
# points to calculate vector field on
allPoint = as.matrix(expand.grid(v, v))
# finer grid to plot the nullclines on
v2 = seq(-3, 3, .01)
params = c(.7, -2, 3, 0) # b is now -2
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(-2, 2, 1),
seq(-2, 2, 1)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params)
# Chunk 8: 4b
res = addTrajectory(inits, params = params, plot = FALSE)
indV = seq(2, ncol(res), 2)
col = rainbow_hcl(length(indV))
layout(matrix(1:2, 1, 2))
matplot(res[, 1], res[, indV], type = "l", lty = 1,
col = col, lwd = 2, bty = 'n', ylim = c(-8, 10),
xlab = "time", ylab = "v", yaxt = "n")
axis(2, at = seq(-8, 10, 2), las = 1)
matplot(res[, 1], res[, indV+1], type = "l", lty = 1,
col = col, lwd = 2, bty = 'n', las = 1,
xlab = "time", ylab = "r")
layout(1)
# params = c(a, b, c, d, I)
dvdr = function(x, y, params) {
# assuming x = v; y = u
# reset condition
if (x >= 30) {
x = params[3]
y = y + params[4]
}
dv = .04*x^2 + 5*x + 140 - y + params[5]
dr = params[1] * (params[2] * x - y)
return(cbind(dv, dr))
}
v_nullcline = function(v, params) .04*v^2 + 5*v + 140 + params[5]
r_nullcline = function(v, params) params[2] * v
# root function
root = function(t, state, params) return(state[1] - 30)
# event function
event = function(t, state, params) {
v = params[3]
u = state[2] + params[4]
return(c(v, u))
}
# time 1 sec by 1ms, like in the paper
time = seq(0, 20, .01)
lv = -100
uv = 30
lu = -40
uu = 20
v = seq(lv, uv, length.out = 21)
u = seq(lu, uu, length.out = 21)
# points to calculate vector field on
allPoint = as.matrix(expand.grid(v, u))
v2 = seq(lv, uv, length.out = 1e4)
# param config for regular spiking
params = c(.02, .2, -65, 8, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
params = c(.1, .2, -65, 2, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
params
layout(matrix(1:2, 1, 2))
params = c(.02, .2, -65, 8, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
params = c(.1, .2, -65, 2, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
params
v = seq(lv, uv, length.out = 21)
u = seq(lu, uu, length.out = 21)
# points to calculate vector field on
allPoint = as.matrix(expand.grid(v, u))
# finer grid to plot the nullclines on
v2 = seq(lv, uv, length.out = 1e4)
# param config for regular spiking
params = c(.02, .2, -65, 8, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
layout(1)
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
res = addTrajectory(inits, params = params,
times = time, plot = FALSE,
events = list(func = event, root = TRUE),
rootfun=root)
indV = seq(2, ncol(res), 2)
col = rainbow_hcl(length(indV))
par(bty = 'n', las = 1, lwd = 2, lty = 1,
mfrow = c(2, 2))
matplot(res[, 1], res[, indV[1:4]], type = "l",lty = 1,
col = col[1:4], xlab = "time", ylab = "v")
matplot(res[, 1], res[, indV[1:4]+1], type = "l", lty = 1,
col = col[1:4], xlab = "time", ylab = "u")
matplot(res[, 1], res[, indV[5:9]], type = "l", lty = 1,
col = col[5:9], xlab = "time", ylab = "v")
matplot(res[, 1], res[, indV[5:9]+1], type = "l", lty = 1,
col = col[5:9], lwd = 2, xlab = "time", ylab = "u")
params = c(.1, .2, -65, 2, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
layout(1)
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
res = addTrajectory(inits, params = params,
times = time, plot = FALSE,
events = list(func = event, root = TRUE),
rootfun=root)
indV = seq(2, ncol(res), 2)
col = rainbow_hcl(length(indV))
par(bty = 'n', las = 1, lwd = 2, lty = 1,
mfrow = c(2, 2))
matplot(res[, 1], res[, indV[1:4]], type = "l",lty = 1,
col = col[1:4], xlab = "time", ylab = "v")
matplot(res[, 1], res[, indV[1:4]+1], type = "l", lty = 1,
col = col[1:4], xlab = "time", ylab = "u")
matplot(res[, 1], res[, indV[5:9]], type = "l", lty = 1,
col = col[5:9], xlab = "time", ylab = "v")
matplot(res[, 1], res[, indV[5:9]+1], type = "l", lty = 1,
col = col[5:9], lwd = 2, xlab = "time", ylab = "u")
params = c(.02, .2, -55, 4, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
layout(1)
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE))
indV
indV = seq(2, ncol(res), 2)
ii1 = 1:6
ii2 = 7:12
col = rainbow_hcl(length(indV))
par(bty = 'n', las = 1, lwd = 2, lty = 1,
mfrow = c(2, 2))
matplot(res[, 1], res[, indV[ii1]], type = "l",lty = 1,
col = col[ii1], xlab = "time", ylab = "v")
matplot(res[, 1], res[, indV[ii1]+1], type = "l", lty = 1,
col = col[ii1], xlab = "time", ylab = "u")
matplot(res[, 1], res[, indV[ii2]], type = "l", lty = 1,
col = col[ii2], xlab = "time", ylab = "v")
matplot(res[, 1], res[, indV[ii2]+1], type = "l", lty = 1,
col = col[ii2], lwd = 2, xlab = "time", ylab = "u")
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
params = c(.02, .2, -65, 8, 10)
vecField = allDvdr(allPoint, params)
# initial values for trajectories
inits = as.matrix(expand.grid(seq(lv, -20, length.out = 3),
seq(lu, uu, length.out = 4)))
# make plot
layout(1)
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE),
times = time)
time
layout(1)
phasePlot(allPoint, vecField, params = params)
addNullClines(v2, params)
addTrajectory(inits, params = params, rootfun = root,
events = list(func = event, root = TRUE)
)
hw = c(19.5, 20, 15, 15)/20
lab = c(79/100, 80/115, 100/100)
md = 28/38
fi = 23/44
hw = c(19.5, 20, 15, 15)/20
(mean(hw) + mean(lab) + md + fi)
mean(hw)
mean(lab)
25*(mean(hw) + mean(lab) + md + fi)
2.5*(mean(hw) + mean(lab) + md + fi)
hw = c(19.5, 20, 15, 15, 17)/20
2.5*(mean(hw) + mean(lab) + md + fi)
mean(hw)
hw = c(19.5, 20, 15, 15)/20
mean(hw)
hw = c(19.5, 20, 15, 15, 17)/20
lab = c(79/100, 80/115, 100/100)
md = 28/38
fi = 23/44
2.5*(mean(hw) + mean(lab) + md + fi)
runApp('C:/Users/donvd/_Laptop/ResMas/Conference/TquanT/Shiny/JamesSteinRemake/shiny.R')
setwd("C:/Users/donvd/_Laptop/ResMas/Conference/TquanT/Shiny/JamesSteinRemake")
rm(list = ls())
setwd('C:/Users/donvd/_Laptop/ResMas/Conference/TquanT/Shiny/JamesSteinRemake/')
source('functions.R')
dat = read.table('Datasets/EffronMorris.txt', header = TRUE, sep = ',')
test = hierarchicalBayes(dat$avg45)
warnings()
dat = read.table('Datasets/EffronMorris.txt', header = TRUE, sep = ',')
test = hierarchicalBayes(dat$avg45)
test
source('C:/Users/donvd/_Laptop/ResMas/Conference/TquanT/Shiny/JamesSteinRemake/functions.R')
test = hierarchicalBayes(dat$avg45, debug = TRUE)
runApp('shiny.R')
runApp('shiny.R')
runApp('shiny.R')
dat = read.table("Datasets/Olympics/Olympics2016.txt", header = TRUE, sep = " ")
head(dat)
runApp('shiny.R')
View(dat)
dat = read.table("Datasets/Olympics/Olympics2016.txt", header = TRUE, sep = " ")
View(dat)
rm(dat)
dat = read.table("Datasets/Olympics/Olympics2016.txt", header = TRUE, sep = " ")
View(dat)
dat = read.table("Datasets/Olympics/Olympics2016.txt", header = TRUE, sep = " ")
View(dat)
runApp('shiny.R')
dat = read.table("Datasets/Olympics2012.txt", header = TRUE, sep = " ")
dat = read.table("Datasets/Olympics2012.txt", header = TRUE, sep = " ")
